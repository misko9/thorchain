// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: types/tx.proto

package types

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Msg_Ban_FullMethodName            = "/types.Msg/Ban"
	Msg_Deposit_FullMethodName        = "/types.Msg/Deposit"
	Msg_ErrataTx_FullMethodName       = "/types.Msg/ErrataTx"
	Msg_Mimir_FullMethodName          = "/types.Msg/Mimir"
	Msg_NetworkFee_FullMethodName     = "/types.Msg/NetworkFee"
	Msg_NodePauseChain_FullMethodName = "/types.Msg/NodePauseChain"
	Msg_ObservedTxIn_FullMethodName   = "/types.Msg/ObservedTxIn"
	Msg_ObservedTxOut_FullMethodName  = "/types.Msg/ObservedTxOut"
	Msg_ThorSend_FullMethodName       = "/types.Msg/ThorSend"
	Msg_SetIPAddress_FullMethodName   = "/types.Msg/SetIPAddress"
	Msg_SetNodeKeys_FullMethodName    = "/types.Msg/SetNodeKeys"
	Msg_Solvency_FullMethodName       = "/types.Msg/Solvency"
	Msg_TssKeysignFail_FullMethodName = "/types.Msg/TssKeysignFail"
	Msg_TssPool_FullMethodName        = "/types.Msg/TssPool"
	Msg_SetVersion_FullMethodName     = "/types.Msg/SetVersion"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MsgClient interface {
	Ban(ctx context.Context, in *MsgBan, opts ...grpc.CallOption) (*MsgEmpty, error)
	Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgEmpty, error)
	ErrataTx(ctx context.Context, in *MsgErrataTx, opts ...grpc.CallOption) (*MsgEmpty, error)
	Mimir(ctx context.Context, in *MsgMimir, opts ...grpc.CallOption) (*MsgEmpty, error)
	NetworkFee(ctx context.Context, in *MsgNetworkFee, opts ...grpc.CallOption) (*MsgEmpty, error)
	NodePauseChain(ctx context.Context, in *MsgNodePauseChain, opts ...grpc.CallOption) (*MsgEmpty, error)
	ObservedTxIn(ctx context.Context, in *MsgObservedTxIn, opts ...grpc.CallOption) (*MsgEmpty, error)
	ObservedTxOut(ctx context.Context, in *MsgObservedTxOut, opts ...grpc.CallOption) (*MsgEmpty, error)
	ThorSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgEmpty, error)
	SetIPAddress(ctx context.Context, in *MsgSetIPAddress, opts ...grpc.CallOption) (*MsgEmpty, error)
	SetNodeKeys(ctx context.Context, in *MsgSetNodeKeys, opts ...grpc.CallOption) (*MsgEmpty, error)
	Solvency(ctx context.Context, in *MsgSolvency, opts ...grpc.CallOption) (*MsgEmpty, error)
	TssKeysignFail(ctx context.Context, in *MsgTssKeysignFail, opts ...grpc.CallOption) (*MsgEmpty, error)
	TssPool(ctx context.Context, in *MsgTssPool, opts ...grpc.CallOption) (*MsgEmpty, error)
	SetVersion(ctx context.Context, in *MsgSetVersion, opts ...grpc.CallOption) (*MsgEmpty, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Ban(ctx context.Context, in *MsgBan, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Ban_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Deposit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ErrataTx(ctx context.Context, in *MsgErrataTx, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ErrataTx_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Mimir(ctx context.Context, in *MsgMimir, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Mimir_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NetworkFee(ctx context.Context, in *MsgNetworkFee, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_NetworkFee_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NodePauseChain(ctx context.Context, in *MsgNodePauseChain, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_NodePauseChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ObservedTxIn(ctx context.Context, in *MsgObservedTxIn, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ObservedTxIn_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ObservedTxOut(ctx context.Context, in *MsgObservedTxOut, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ObservedTxOut_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ThorSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ThorSend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetIPAddress(ctx context.Context, in *MsgSetIPAddress, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_SetIPAddress_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNodeKeys(ctx context.Context, in *MsgSetNodeKeys, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_SetNodeKeys_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Solvency(ctx context.Context, in *MsgSolvency, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Solvency_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TssKeysignFail(ctx context.Context, in *MsgTssKeysignFail, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_TssKeysignFail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TssPool(ctx context.Context, in *MsgTssPool, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_TssPool_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetVersion(ctx context.Context, in *MsgSetVersion, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_SetVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility
type MsgServer interface {
	Ban(context.Context, *MsgBan) (*MsgEmpty, error)
	Deposit(context.Context, *MsgDeposit) (*MsgEmpty, error)
	ErrataTx(context.Context, *MsgErrataTx) (*MsgEmpty, error)
	Mimir(context.Context, *MsgMimir) (*MsgEmpty, error)
	NetworkFee(context.Context, *MsgNetworkFee) (*MsgEmpty, error)
	NodePauseChain(context.Context, *MsgNodePauseChain) (*MsgEmpty, error)
	ObservedTxIn(context.Context, *MsgObservedTxIn) (*MsgEmpty, error)
	ObservedTxOut(context.Context, *MsgObservedTxOut) (*MsgEmpty, error)
	ThorSend(context.Context, *MsgSend) (*MsgEmpty, error)
	SetIPAddress(context.Context, *MsgSetIPAddress) (*MsgEmpty, error)
	SetNodeKeys(context.Context, *MsgSetNodeKeys) (*MsgEmpty, error)
	Solvency(context.Context, *MsgSolvency) (*MsgEmpty, error)
	TssKeysignFail(context.Context, *MsgTssKeysignFail) (*MsgEmpty, error)
	TssPool(context.Context, *MsgTssPool) (*MsgEmpty, error)
	SetVersion(context.Context, *MsgSetVersion) (*MsgEmpty, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (UnimplementedMsgServer) Ban(context.Context, *MsgBan) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ban not implemented")
}
func (UnimplementedMsgServer) Deposit(context.Context, *MsgDeposit) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (UnimplementedMsgServer) ErrataTx(context.Context, *MsgErrataTx) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ErrataTx not implemented")
}
func (UnimplementedMsgServer) Mimir(context.Context, *MsgMimir) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mimir not implemented")
}
func (UnimplementedMsgServer) NetworkFee(context.Context, *MsgNetworkFee) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NetworkFee not implemented")
}
func (UnimplementedMsgServer) NodePauseChain(context.Context, *MsgNodePauseChain) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodePauseChain not implemented")
}
func (UnimplementedMsgServer) ObservedTxIn(context.Context, *MsgObservedTxIn) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObservedTxIn not implemented")
}
func (UnimplementedMsgServer) ObservedTxOut(context.Context, *MsgObservedTxOut) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObservedTxOut not implemented")
}
func (UnimplementedMsgServer) ThorSend(context.Context, *MsgSend) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ThorSend not implemented")
}
func (UnimplementedMsgServer) SetIPAddress(context.Context, *MsgSetIPAddress) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIPAddress not implemented")
}
func (UnimplementedMsgServer) SetNodeKeys(context.Context, *MsgSetNodeKeys) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNodeKeys not implemented")
}
func (UnimplementedMsgServer) Solvency(context.Context, *MsgSolvency) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Solvency not implemented")
}
func (UnimplementedMsgServer) TssKeysignFail(context.Context, *MsgTssKeysignFail) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TssKeysignFail not implemented")
}
func (UnimplementedMsgServer) TssPool(context.Context, *MsgTssPool) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TssPool not implemented")
}
func (UnimplementedMsgServer) SetVersion(context.Context, *MsgSetVersion) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVersion not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_Ban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Ban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Ban_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Ban(ctx, req.(*MsgBan))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Deposit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Deposit(ctx, req.(*MsgDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ErrataTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgErrataTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ErrataTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ErrataTx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ErrataTx(ctx, req.(*MsgErrataTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Mimir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMimir)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Mimir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Mimir_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Mimir(ctx, req.(*MsgMimir))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NetworkFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNetworkFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NetworkFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NetworkFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NetworkFee(ctx, req.(*MsgNetworkFee))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NodePauseChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNodePauseChain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NodePauseChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NodePauseChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NodePauseChain(ctx, req.(*MsgNodePauseChain))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ObservedTxIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgObservedTxIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ObservedTxIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ObservedTxIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ObservedTxIn(ctx, req.(*MsgObservedTxIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ObservedTxOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgObservedTxOut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ObservedTxOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ObservedTxOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ObservedTxOut(ctx, req.(*MsgObservedTxOut))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ThorSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ThorSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ThorSend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ThorSend(ctx, req.(*MsgSend))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetIPAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetIPAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetIPAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetIPAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetIPAddress(ctx, req.(*MsgSetIPAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNodeKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNodeKeys)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNodeKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetNodeKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNodeKeys(ctx, req.(*MsgSetNodeKeys))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Solvency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSolvency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Solvency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Solvency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Solvency(ctx, req.(*MsgSolvency))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TssKeysignFail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTssKeysignFail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TssKeysignFail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_TssKeysignFail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TssKeysignFail(ctx, req.(*MsgTssKeysignFail))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TssPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTssPool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TssPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_TssPool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TssPool(ctx, req.(*MsgTssPool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetVersion)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetVersion(ctx, req.(*MsgSetVersion))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "types.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ban",
			Handler:    _Msg_Ban_Handler,
		},
		{
			MethodName: "Deposit",
			Handler:    _Msg_Deposit_Handler,
		},
		{
			MethodName: "ErrataTx",
			Handler:    _Msg_ErrataTx_Handler,
		},
		{
			MethodName: "Mimir",
			Handler:    _Msg_Mimir_Handler,
		},
		{
			MethodName: "NetworkFee",
			Handler:    _Msg_NetworkFee_Handler,
		},
		{
			MethodName: "NodePauseChain",
			Handler:    _Msg_NodePauseChain_Handler,
		},
		{
			MethodName: "ObservedTxIn",
			Handler:    _Msg_ObservedTxIn_Handler,
		},
		{
			MethodName: "ObservedTxOut",
			Handler:    _Msg_ObservedTxOut_Handler,
		},
		{
			MethodName: "ThorSend",
			Handler:    _Msg_ThorSend_Handler,
		},
		{
			MethodName: "SetIPAddress",
			Handler:    _Msg_SetIPAddress_Handler,
		},
		{
			MethodName: "SetNodeKeys",
			Handler:    _Msg_SetNodeKeys_Handler,
		},
		{
			MethodName: "Solvency",
			Handler:    _Msg_Solvency_Handler,
		},
		{
			MethodName: "TssKeysignFail",
			Handler:    _Msg_TssKeysignFail_Handler,
		},
		{
			MethodName: "TssPool",
			Handler:    _Msg_TssPool_Handler,
		},
		{
			MethodName: "SetVersion",
			Handler:    _Msg_SetVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "types/tx.proto",
}
