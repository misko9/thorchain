// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: types/tx.proto

package types

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Msg_AddLiquidity_FullMethodName           = "/types.Msg/AddLiquidity"
	Msg_Ban_FullMethodName                    = "/types.Msg/Ban"
	Msg_Bond_FullMethodName                   = "/types.Msg/Bond"
	Msg_Consolidate_FullMethodName            = "/types.Msg/Consolidate"
	Msg_Deposit_FullMethodName                = "/types.Msg/Deposit"
	Msg_Donate_FullMethodName                 = "/types.Msg/Donate"
	Msg_ErrataTx_FullMethodName               = "/types.Msg/ErrataTx"
	Msg_Leave_FullMethodName                  = "/types.Msg/Leave"
	Msg_LoanOpen_FullMethodName               = "/types.Msg/LoanOpen"
	Msg_LoanRepayment_FullMethodName          = "/types.Msg/LoanRepayment"
	Msg_ManageThorname_FullMethodName         = "/types.Msg/ManageThorname"
	Msg_Migrate_FullMethodName                = "/types.Msg/Migrate"
	Msg_Mimir_FullMethodName                  = "/types.Msg/Mimir"
	Msg_NetworkFee_FullMethodName             = "/types.Msg/NetworkFee"
	Msg_NodePauseChain_FullMethodName         = "/types.Msg/NodePauseChain"
	Msg_Noop_FullMethodName                   = "/types.Msg/Noop"
	Msg_ObservedTxIn_FullMethodName           = "/types.Msg/ObservedTxIn"
	Msg_ObservedTxOut_FullMethodName          = "/types.Msg/ObservedTxOut"
	Msg_Ragnarok_FullMethodName               = "/types.Msg/Ragnarok"
	Msg_RefundTx_FullMethodName               = "/types.Msg/RefundTx"
	Msg_ReserveContributor_FullMethodName     = "/types.Msg/ReserveContributor"
	Msg_RunePoolDeposit_FullMethodName        = "/types.Msg/RunePoolDeposit"
	Msg_RunePoolWithdraw_FullMethodName       = "/types.Msg/RunePoolWithdraw"
	Msg_ThorSend_FullMethodName               = "/types.Msg/ThorSend"
	Msg_SetIPAddress_FullMethodName           = "/types.Msg/SetIPAddress"
	Msg_SetNodeKeys_FullMethodName            = "/types.Msg/SetNodeKeys"
	Msg_Solvency_FullMethodName               = "/types.Msg/Solvency"
	Msg_Swap_FullMethodName                   = "/types.Msg/Swap"
	Msg_TradeAccountDeposit_FullMethodName    = "/types.Msg/TradeAccountDeposit"
	Msg_TradeAccountWithdrawal_FullMethodName = "/types.Msg/TradeAccountWithdrawal"
	Msg_TssKeysignFail_FullMethodName         = "/types.Msg/TssKeysignFail"
	Msg_TssPool_FullMethodName                = "/types.Msg/TssPool"
	Msg_OutboundTx_FullMethodName             = "/types.Msg/OutboundTx"
	Msg_UnBond_FullMethodName                 = "/types.Msg/UnBond"
	Msg_SetVersion_FullMethodName             = "/types.Msg/SetVersion"
	Msg_WithdrawLiquidity_FullMethodName      = "/types.Msg/WithdrawLiquidity"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MsgClient interface {
	AddLiquidity(ctx context.Context, in *MsgAddLiquidity, opts ...grpc.CallOption) (*MsgEmpty, error)
	Ban(ctx context.Context, in *MsgBan, opts ...grpc.CallOption) (*MsgEmpty, error)
	Bond(ctx context.Context, in *MsgBond, opts ...grpc.CallOption) (*MsgEmpty, error)
	Consolidate(ctx context.Context, in *MsgConsolidate, opts ...grpc.CallOption) (*MsgEmpty, error)
	Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgEmpty, error)
	Donate(ctx context.Context, in *MsgDonate, opts ...grpc.CallOption) (*MsgEmpty, error)
	ErrataTx(ctx context.Context, in *MsgErrataTx, opts ...grpc.CallOption) (*MsgEmpty, error)
	Leave(ctx context.Context, in *MsgLeave, opts ...grpc.CallOption) (*MsgEmpty, error)
	LoanOpen(ctx context.Context, in *MsgLoanOpen, opts ...grpc.CallOption) (*MsgEmpty, error)
	LoanRepayment(ctx context.Context, in *MsgLoanRepayment, opts ...grpc.CallOption) (*MsgEmpty, error)
	ManageThorname(ctx context.Context, in *MsgManageTHORName, opts ...grpc.CallOption) (*MsgEmpty, error)
	Migrate(ctx context.Context, in *MsgMigrate, opts ...grpc.CallOption) (*MsgEmpty, error)
	Mimir(ctx context.Context, in *MsgMimir, opts ...grpc.CallOption) (*MsgEmpty, error)
	NetworkFee(ctx context.Context, in *MsgNetworkFee, opts ...grpc.CallOption) (*MsgEmpty, error)
	NodePauseChain(ctx context.Context, in *MsgNodePauseChain, opts ...grpc.CallOption) (*MsgEmpty, error)
	Noop(ctx context.Context, in *MsgNoOp, opts ...grpc.CallOption) (*MsgEmpty, error)
	ObservedTxIn(ctx context.Context, in *MsgObservedTxIn, opts ...grpc.CallOption) (*MsgEmpty, error)
	ObservedTxOut(ctx context.Context, in *MsgObservedTxOut, opts ...grpc.CallOption) (*MsgEmpty, error)
	Ragnarok(ctx context.Context, in *MsgRagnarok, opts ...grpc.CallOption) (*MsgEmpty, error)
	RefundTx(ctx context.Context, in *MsgRefundTx, opts ...grpc.CallOption) (*MsgEmpty, error)
	ReserveContributor(ctx context.Context, in *MsgReserveContributor, opts ...grpc.CallOption) (*MsgEmpty, error)
	RunePoolDeposit(ctx context.Context, in *MsgRunePoolDeposit, opts ...grpc.CallOption) (*MsgEmpty, error)
	RunePoolWithdraw(ctx context.Context, in *MsgRunePoolWithdraw, opts ...grpc.CallOption) (*MsgEmpty, error)
	ThorSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgEmpty, error)
	SetIPAddress(ctx context.Context, in *MsgSetIPAddress, opts ...grpc.CallOption) (*MsgEmpty, error)
	SetNodeKeys(ctx context.Context, in *MsgSetNodeKeys, opts ...grpc.CallOption) (*MsgEmpty, error)
	Solvency(ctx context.Context, in *MsgSolvency, opts ...grpc.CallOption) (*MsgEmpty, error)
	Swap(ctx context.Context, in *MsgSwap, opts ...grpc.CallOption) (*MsgEmpty, error)
	TradeAccountDeposit(ctx context.Context, in *MsgTradeAccountDeposit, opts ...grpc.CallOption) (*MsgEmpty, error)
	TradeAccountWithdrawal(ctx context.Context, in *MsgTradeAccountWithdrawal, opts ...grpc.CallOption) (*MsgEmpty, error)
	TssKeysignFail(ctx context.Context, in *MsgTssKeysignFail, opts ...grpc.CallOption) (*MsgEmpty, error)
	TssPool(ctx context.Context, in *MsgTssPool, opts ...grpc.CallOption) (*MsgEmpty, error)
	OutboundTx(ctx context.Context, in *MsgOutboundTx, opts ...grpc.CallOption) (*MsgEmpty, error)
	UnBond(ctx context.Context, in *MsgUnBond, opts ...grpc.CallOption) (*MsgEmpty, error)
	SetVersion(ctx context.Context, in *MsgSetVersion, opts ...grpc.CallOption) (*MsgEmpty, error)
	WithdrawLiquidity(ctx context.Context, in *MsgWithdrawLiquidity, opts ...grpc.CallOption) (*MsgEmpty, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) AddLiquidity(ctx context.Context, in *MsgAddLiquidity, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_AddLiquidity_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Ban(ctx context.Context, in *MsgBan, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Ban_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Bond(ctx context.Context, in *MsgBond, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Bond_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Consolidate(ctx context.Context, in *MsgConsolidate, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Consolidate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Deposit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Donate(ctx context.Context, in *MsgDonate, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Donate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ErrataTx(ctx context.Context, in *MsgErrataTx, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ErrataTx_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Leave(ctx context.Context, in *MsgLeave, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Leave_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) LoanOpen(ctx context.Context, in *MsgLoanOpen, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_LoanOpen_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) LoanRepayment(ctx context.Context, in *MsgLoanRepayment, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_LoanRepayment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ManageThorname(ctx context.Context, in *MsgManageTHORName, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ManageThorname_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Migrate(ctx context.Context, in *MsgMigrate, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Migrate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Mimir(ctx context.Context, in *MsgMimir, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Mimir_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NetworkFee(ctx context.Context, in *MsgNetworkFee, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_NetworkFee_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NodePauseChain(ctx context.Context, in *MsgNodePauseChain, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_NodePauseChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Noop(ctx context.Context, in *MsgNoOp, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Noop_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ObservedTxIn(ctx context.Context, in *MsgObservedTxIn, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ObservedTxIn_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ObservedTxOut(ctx context.Context, in *MsgObservedTxOut, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ObservedTxOut_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Ragnarok(ctx context.Context, in *MsgRagnarok, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Ragnarok_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RefundTx(ctx context.Context, in *MsgRefundTx, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_RefundTx_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReserveContributor(ctx context.Context, in *MsgReserveContributor, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ReserveContributor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RunePoolDeposit(ctx context.Context, in *MsgRunePoolDeposit, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_RunePoolDeposit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RunePoolWithdraw(ctx context.Context, in *MsgRunePoolWithdraw, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_RunePoolWithdraw_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ThorSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ThorSend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetIPAddress(ctx context.Context, in *MsgSetIPAddress, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_SetIPAddress_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNodeKeys(ctx context.Context, in *MsgSetNodeKeys, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_SetNodeKeys_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Solvency(ctx context.Context, in *MsgSolvency, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Solvency_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Swap(ctx context.Context, in *MsgSwap, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Swap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TradeAccountDeposit(ctx context.Context, in *MsgTradeAccountDeposit, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_TradeAccountDeposit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TradeAccountWithdrawal(ctx context.Context, in *MsgTradeAccountWithdrawal, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_TradeAccountWithdrawal_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TssKeysignFail(ctx context.Context, in *MsgTssKeysignFail, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_TssKeysignFail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TssPool(ctx context.Context, in *MsgTssPool, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_TssPool_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OutboundTx(ctx context.Context, in *MsgOutboundTx, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_OutboundTx_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UnBond(ctx context.Context, in *MsgUnBond, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_UnBond_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetVersion(ctx context.Context, in *MsgSetVersion, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_SetVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) WithdrawLiquidity(ctx context.Context, in *MsgWithdrawLiquidity, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_WithdrawLiquidity_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility
type MsgServer interface {
	AddLiquidity(context.Context, *MsgAddLiquidity) (*MsgEmpty, error)
	Ban(context.Context, *MsgBan) (*MsgEmpty, error)
	Bond(context.Context, *MsgBond) (*MsgEmpty, error)
	Consolidate(context.Context, *MsgConsolidate) (*MsgEmpty, error)
	Deposit(context.Context, *MsgDeposit) (*MsgEmpty, error)
	Donate(context.Context, *MsgDonate) (*MsgEmpty, error)
	ErrataTx(context.Context, *MsgErrataTx) (*MsgEmpty, error)
	Leave(context.Context, *MsgLeave) (*MsgEmpty, error)
	LoanOpen(context.Context, *MsgLoanOpen) (*MsgEmpty, error)
	LoanRepayment(context.Context, *MsgLoanRepayment) (*MsgEmpty, error)
	ManageThorname(context.Context, *MsgManageTHORName) (*MsgEmpty, error)
	Migrate(context.Context, *MsgMigrate) (*MsgEmpty, error)
	Mimir(context.Context, *MsgMimir) (*MsgEmpty, error)
	NetworkFee(context.Context, *MsgNetworkFee) (*MsgEmpty, error)
	NodePauseChain(context.Context, *MsgNodePauseChain) (*MsgEmpty, error)
	Noop(context.Context, *MsgNoOp) (*MsgEmpty, error)
	ObservedTxIn(context.Context, *MsgObservedTxIn) (*MsgEmpty, error)
	ObservedTxOut(context.Context, *MsgObservedTxOut) (*MsgEmpty, error)
	Ragnarok(context.Context, *MsgRagnarok) (*MsgEmpty, error)
	RefundTx(context.Context, *MsgRefundTx) (*MsgEmpty, error)
	ReserveContributor(context.Context, *MsgReserveContributor) (*MsgEmpty, error)
	RunePoolDeposit(context.Context, *MsgRunePoolDeposit) (*MsgEmpty, error)
	RunePoolWithdraw(context.Context, *MsgRunePoolWithdraw) (*MsgEmpty, error)
	ThorSend(context.Context, *MsgSend) (*MsgEmpty, error)
	SetIPAddress(context.Context, *MsgSetIPAddress) (*MsgEmpty, error)
	SetNodeKeys(context.Context, *MsgSetNodeKeys) (*MsgEmpty, error)
	Solvency(context.Context, *MsgSolvency) (*MsgEmpty, error)
	Swap(context.Context, *MsgSwap) (*MsgEmpty, error)
	TradeAccountDeposit(context.Context, *MsgTradeAccountDeposit) (*MsgEmpty, error)
	TradeAccountWithdrawal(context.Context, *MsgTradeAccountWithdrawal) (*MsgEmpty, error)
	TssKeysignFail(context.Context, *MsgTssKeysignFail) (*MsgEmpty, error)
	TssPool(context.Context, *MsgTssPool) (*MsgEmpty, error)
	OutboundTx(context.Context, *MsgOutboundTx) (*MsgEmpty, error)
	UnBond(context.Context, *MsgUnBond) (*MsgEmpty, error)
	SetVersion(context.Context, *MsgSetVersion) (*MsgEmpty, error)
	WithdrawLiquidity(context.Context, *MsgWithdrawLiquidity) (*MsgEmpty, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (UnimplementedMsgServer) AddLiquidity(context.Context, *MsgAddLiquidity) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLiquidity not implemented")
}
func (UnimplementedMsgServer) Ban(context.Context, *MsgBan) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ban not implemented")
}
func (UnimplementedMsgServer) Bond(context.Context, *MsgBond) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bond not implemented")
}
func (UnimplementedMsgServer) Consolidate(context.Context, *MsgConsolidate) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Consolidate not implemented")
}
func (UnimplementedMsgServer) Deposit(context.Context, *MsgDeposit) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (UnimplementedMsgServer) Donate(context.Context, *MsgDonate) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Donate not implemented")
}
func (UnimplementedMsgServer) ErrataTx(context.Context, *MsgErrataTx) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ErrataTx not implemented")
}
func (UnimplementedMsgServer) Leave(context.Context, *MsgLeave) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Leave not implemented")
}
func (UnimplementedMsgServer) LoanOpen(context.Context, *MsgLoanOpen) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoanOpen not implemented")
}
func (UnimplementedMsgServer) LoanRepayment(context.Context, *MsgLoanRepayment) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoanRepayment not implemented")
}
func (UnimplementedMsgServer) ManageThorname(context.Context, *MsgManageTHORName) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ManageThorname not implemented")
}
func (UnimplementedMsgServer) Migrate(context.Context, *MsgMigrate) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Migrate not implemented")
}
func (UnimplementedMsgServer) Mimir(context.Context, *MsgMimir) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mimir not implemented")
}
func (UnimplementedMsgServer) NetworkFee(context.Context, *MsgNetworkFee) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NetworkFee not implemented")
}
func (UnimplementedMsgServer) NodePauseChain(context.Context, *MsgNodePauseChain) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodePauseChain not implemented")
}
func (UnimplementedMsgServer) Noop(context.Context, *MsgNoOp) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Noop not implemented")
}
func (UnimplementedMsgServer) ObservedTxIn(context.Context, *MsgObservedTxIn) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObservedTxIn not implemented")
}
func (UnimplementedMsgServer) ObservedTxOut(context.Context, *MsgObservedTxOut) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObservedTxOut not implemented")
}
func (UnimplementedMsgServer) Ragnarok(context.Context, *MsgRagnarok) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ragnarok not implemented")
}
func (UnimplementedMsgServer) RefundTx(context.Context, *MsgRefundTx) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefundTx not implemented")
}
func (UnimplementedMsgServer) ReserveContributor(context.Context, *MsgReserveContributor) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReserveContributor not implemented")
}
func (UnimplementedMsgServer) RunePoolDeposit(context.Context, *MsgRunePoolDeposit) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunePoolDeposit not implemented")
}
func (UnimplementedMsgServer) RunePoolWithdraw(context.Context, *MsgRunePoolWithdraw) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunePoolWithdraw not implemented")
}
func (UnimplementedMsgServer) ThorSend(context.Context, *MsgSend) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ThorSend not implemented")
}
func (UnimplementedMsgServer) SetIPAddress(context.Context, *MsgSetIPAddress) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIPAddress not implemented")
}
func (UnimplementedMsgServer) SetNodeKeys(context.Context, *MsgSetNodeKeys) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNodeKeys not implemented")
}
func (UnimplementedMsgServer) Solvency(context.Context, *MsgSolvency) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Solvency not implemented")
}
func (UnimplementedMsgServer) Swap(context.Context, *MsgSwap) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Swap not implemented")
}
func (UnimplementedMsgServer) TradeAccountDeposit(context.Context, *MsgTradeAccountDeposit) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TradeAccountDeposit not implemented")
}
func (UnimplementedMsgServer) TradeAccountWithdrawal(context.Context, *MsgTradeAccountWithdrawal) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TradeAccountWithdrawal not implemented")
}
func (UnimplementedMsgServer) TssKeysignFail(context.Context, *MsgTssKeysignFail) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TssKeysignFail not implemented")
}
func (UnimplementedMsgServer) TssPool(context.Context, *MsgTssPool) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TssPool not implemented")
}
func (UnimplementedMsgServer) OutboundTx(context.Context, *MsgOutboundTx) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OutboundTx not implemented")
}
func (UnimplementedMsgServer) UnBond(context.Context, *MsgUnBond) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnBond not implemented")
}
func (UnimplementedMsgServer) SetVersion(context.Context, *MsgSetVersion) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVersion not implemented")
}
func (UnimplementedMsgServer) WithdrawLiquidity(context.Context, *MsgWithdrawLiquidity) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawLiquidity not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_AddLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddLiquidity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AddLiquidity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddLiquidity(ctx, req.(*MsgAddLiquidity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Ban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Ban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Ban_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Ban(ctx, req.(*MsgBan))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Bond_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBond)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Bond(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Bond_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Bond(ctx, req.(*MsgBond))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Consolidate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgConsolidate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Consolidate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Consolidate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Consolidate(ctx, req.(*MsgConsolidate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Deposit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Deposit(ctx, req.(*MsgDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Donate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDonate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Donate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Donate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Donate(ctx, req.(*MsgDonate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ErrataTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgErrataTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ErrataTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ErrataTx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ErrataTx(ctx, req.(*MsgErrataTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Leave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLeave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Leave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Leave_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Leave(ctx, req.(*MsgLeave))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_LoanOpen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLoanOpen)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).LoanOpen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_LoanOpen_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).LoanOpen(ctx, req.(*MsgLoanOpen))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_LoanRepayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLoanRepayment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).LoanRepayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_LoanRepayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).LoanRepayment(ctx, req.(*MsgLoanRepayment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ManageThorname_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgManageTHORName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ManageThorname(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ManageThorname_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ManageThorname(ctx, req.(*MsgManageTHORName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Migrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMigrate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Migrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Migrate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Migrate(ctx, req.(*MsgMigrate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Mimir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMimir)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Mimir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Mimir_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Mimir(ctx, req.(*MsgMimir))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NetworkFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNetworkFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NetworkFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NetworkFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NetworkFee(ctx, req.(*MsgNetworkFee))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NodePauseChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNodePauseChain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NodePauseChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NodePauseChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NodePauseChain(ctx, req.(*MsgNodePauseChain))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Noop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNoOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Noop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Noop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Noop(ctx, req.(*MsgNoOp))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ObservedTxIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgObservedTxIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ObservedTxIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ObservedTxIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ObservedTxIn(ctx, req.(*MsgObservedTxIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ObservedTxOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgObservedTxOut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ObservedTxOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ObservedTxOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ObservedTxOut(ctx, req.(*MsgObservedTxOut))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Ragnarok_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRagnarok)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Ragnarok(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Ragnarok_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Ragnarok(ctx, req.(*MsgRagnarok))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RefundTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRefundTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RefundTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RefundTx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RefundTx(ctx, req.(*MsgRefundTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReserveContributor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReserveContributor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReserveContributor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ReserveContributor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReserveContributor(ctx, req.(*MsgReserveContributor))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RunePoolDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRunePoolDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RunePoolDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RunePoolDeposit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RunePoolDeposit(ctx, req.(*MsgRunePoolDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RunePoolWithdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRunePoolWithdraw)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RunePoolWithdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RunePoolWithdraw_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RunePoolWithdraw(ctx, req.(*MsgRunePoolWithdraw))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ThorSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ThorSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ThorSend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ThorSend(ctx, req.(*MsgSend))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetIPAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetIPAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetIPAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetIPAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetIPAddress(ctx, req.(*MsgSetIPAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNodeKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNodeKeys)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNodeKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetNodeKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNodeKeys(ctx, req.(*MsgSetNodeKeys))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Solvency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSolvency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Solvency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Solvency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Solvency(ctx, req.(*MsgSolvency))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Swap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSwap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Swap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Swap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Swap(ctx, req.(*MsgSwap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TradeAccountDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTradeAccountDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TradeAccountDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_TradeAccountDeposit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TradeAccountDeposit(ctx, req.(*MsgTradeAccountDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TradeAccountWithdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTradeAccountWithdrawal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TradeAccountWithdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_TradeAccountWithdrawal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TradeAccountWithdrawal(ctx, req.(*MsgTradeAccountWithdrawal))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TssKeysignFail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTssKeysignFail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TssKeysignFail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_TssKeysignFail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TssKeysignFail(ctx, req.(*MsgTssKeysignFail))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TssPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTssPool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TssPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_TssPool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TssPool(ctx, req.(*MsgTssPool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OutboundTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOutboundTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OutboundTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_OutboundTx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OutboundTx(ctx, req.(*MsgOutboundTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UnBond_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUnBond)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UnBond(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UnBond_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UnBond(ctx, req.(*MsgUnBond))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetVersion)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetVersion(ctx, req.(*MsgSetVersion))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_WithdrawLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdrawLiquidity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).WithdrawLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_WithdrawLiquidity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).WithdrawLiquidity(ctx, req.(*MsgWithdrawLiquidity))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "types.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddLiquidity",
			Handler:    _Msg_AddLiquidity_Handler,
		},
		{
			MethodName: "Ban",
			Handler:    _Msg_Ban_Handler,
		},
		{
			MethodName: "Bond",
			Handler:    _Msg_Bond_Handler,
		},
		{
			MethodName: "Consolidate",
			Handler:    _Msg_Consolidate_Handler,
		},
		{
			MethodName: "Deposit",
			Handler:    _Msg_Deposit_Handler,
		},
		{
			MethodName: "Donate",
			Handler:    _Msg_Donate_Handler,
		},
		{
			MethodName: "ErrataTx",
			Handler:    _Msg_ErrataTx_Handler,
		},
		{
			MethodName: "Leave",
			Handler:    _Msg_Leave_Handler,
		},
		{
			MethodName: "LoanOpen",
			Handler:    _Msg_LoanOpen_Handler,
		},
		{
			MethodName: "LoanRepayment",
			Handler:    _Msg_LoanRepayment_Handler,
		},
		{
			MethodName: "ManageThorname",
			Handler:    _Msg_ManageThorname_Handler,
		},
		{
			MethodName: "Migrate",
			Handler:    _Msg_Migrate_Handler,
		},
		{
			MethodName: "Mimir",
			Handler:    _Msg_Mimir_Handler,
		},
		{
			MethodName: "NetworkFee",
			Handler:    _Msg_NetworkFee_Handler,
		},
		{
			MethodName: "NodePauseChain",
			Handler:    _Msg_NodePauseChain_Handler,
		},
		{
			MethodName: "Noop",
			Handler:    _Msg_Noop_Handler,
		},
		{
			MethodName: "ObservedTxIn",
			Handler:    _Msg_ObservedTxIn_Handler,
		},
		{
			MethodName: "ObservedTxOut",
			Handler:    _Msg_ObservedTxOut_Handler,
		},
		{
			MethodName: "Ragnarok",
			Handler:    _Msg_Ragnarok_Handler,
		},
		{
			MethodName: "RefundTx",
			Handler:    _Msg_RefundTx_Handler,
		},
		{
			MethodName: "ReserveContributor",
			Handler:    _Msg_ReserveContributor_Handler,
		},
		{
			MethodName: "RunePoolDeposit",
			Handler:    _Msg_RunePoolDeposit_Handler,
		},
		{
			MethodName: "RunePoolWithdraw",
			Handler:    _Msg_RunePoolWithdraw_Handler,
		},
		{
			MethodName: "ThorSend",
			Handler:    _Msg_ThorSend_Handler,
		},
		{
			MethodName: "SetIPAddress",
			Handler:    _Msg_SetIPAddress_Handler,
		},
		{
			MethodName: "SetNodeKeys",
			Handler:    _Msg_SetNodeKeys_Handler,
		},
		{
			MethodName: "Solvency",
			Handler:    _Msg_Solvency_Handler,
		},
		{
			MethodName: "Swap",
			Handler:    _Msg_Swap_Handler,
		},
		{
			MethodName: "TradeAccountDeposit",
			Handler:    _Msg_TradeAccountDeposit_Handler,
		},
		{
			MethodName: "TradeAccountWithdrawal",
			Handler:    _Msg_TradeAccountWithdrawal_Handler,
		},
		{
			MethodName: "TssKeysignFail",
			Handler:    _Msg_TssKeysignFail_Handler,
		},
		{
			MethodName: "TssPool",
			Handler:    _Msg_TssPool_Handler,
		},
		{
			MethodName: "OutboundTx",
			Handler:    _Msg_OutboundTx_Handler,
		},
		{
			MethodName: "UnBond",
			Handler:    _Msg_UnBond_Handler,
		},
		{
			MethodName: "SetVersion",
			Handler:    _Msg_SetVersion_Handler,
		},
		{
			MethodName: "WithdrawLiquidity",
			Handler:    _Msg_WithdrawLiquidity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "types/tx.proto",
}
